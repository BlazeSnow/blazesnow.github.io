{"version":3,"file":"docsify-tabs.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n  tabsContainer: 'content',\n  tabBlock: 'docsify-tabs',\n  tabButton: 'docsify-tabs__tab',\n  tabButtonActive: 'docsify-tabs__tab--active',\n  tabContent: 'docsify-tabs__content'\n};\nconst regex = {\n  // Matches markdown code blocks (inline and multi-line)\n  // Example: ```text```\n  codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n  // Matches tab replacement comment\n  // 0: Match\n  // 1: Replacement HTML\n  commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*?) -->`),\n\n  // Matches inner-most tab set by start/end comment\n  // Ex: <!-- tabs:start --> (<!-- tabs:start --><!-- tabs:end -->) <!-- tabs:end -->\n  // 0: Match\n  // 1: Indent\n  // 2: Start comment: <!-- tabs:start -->\n  // 3: undefined\n  // 4: End comment: <!-- tabs:end -->\n  tabBlockMarkup:\n    /( *)(<!-+\\s+tabs:\\s*?start\\s+-+>)(?:(?!(<!-+\\s+tabs:\\s*?(?:start|end)\\s+-+>))[\\s\\S])*(<!-+\\s+tabs:\\s*?end\\s+-+>)/,\n\n  // Matches tab label and content\n  // 0: Match\n  // 1: Label: <!-- tab:Label -->\n  // 2: Content\n  tabCommentMarkup:\n    /[\\r\\n]*(\\s*)<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]*\\s*(?=<!-+\\s+tabs?:(?!replace))/m,\n\n  // Matches tab label and content\n  // 0: Match\n  // 1: Label: #### **Label** OR #### __Label__\n  // 2: Content\n  tabHeadingMarkup:\n    /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n  persist: true,\n  sync: true,\n  theme: 'classic',\n  tabComments: true,\n  tabHeadings: true\n};\n\nconst storageKeys = {\n  get persist() {\n    return `docsify-tabs.persist.${window.location.pathname}`;\n  },\n  sync: 'docsify-tabs.sync'\n};\n\n// Functions\n// =============================================================================\n/**\n * Traverses the element and its parents until it finds a node that matches the\n * provided selector string. Will return itself or the matching ancestor.\n *\n * @param {object} elm\n * @param {string} closestSelectorString\n * @return {(object|null)}\n */\nfunction getClosest(elm, closestSelectorString) {\n  if (Element.prototype.closest) {\n    return elm.closest(closestSelectorString);\n  }\n\n  while (elm) {\n    const isMatch = matchSelector(elm, closestSelectorString);\n\n    if (isMatch) {\n      return elm;\n    }\n\n    elm = elm.parentNode || null;\n  }\n\n  return elm;\n}\n\n/**\n * Checks to see if the element would be selected by the provided selectorString\n *\n * @param {object} elm\n * @param {string} selectorString\n * @return {boolean}\n */\nfunction matchSelector(elm, selectorString) {\n  const matches =\n    Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\n  return matches.call(elm, selectorString);\n}\n\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content, vm) {\n  const codeBlockMatch = content.match(regex.codeMarkup) || [];\n  const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n    const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n    // Replace code block with marker to ensure tab markup within code\n    // blocks is not processed. These markers are replaced with their\n    // associated code blocs after tabs have been processed.\n    content = content.replace(item, () => codeMarker);\n\n    return codeMarker;\n  });\n  const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n  const tempElm = document.createElement('div');\n\n  let tabBlockMatch = content.match(regex.tabBlockMarkup);\n  let tabIndex = 1;\n\n  // Process each tab set\n  while (tabBlockMatch) {\n    let tabBlockOut = tabBlockMatch[0];\n\n    const tabBlockIndent = tabBlockMatch[1];\n    const tabBlockStart = tabBlockMatch[2];\n    const tabBlockEnd = tabBlockMatch[4];\n    const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlockOut);\n    const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlockOut);\n\n    let tabMatch;\n    let tabStartReplacement = '';\n    let tabEndReplacement = '';\n\n    if (hasTabComments || hasTabHeadings) {\n      tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n      tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n      // Process each tab panel\n      while (\n        (tabMatch =\n          (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlockOut) : null) ||\n          (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlockOut) : null)) !== null\n      ) {\n        // Process tab title as markdown\n        // Ex: <!-- tab:**Bold** and <span style=\"color: red;\">red</span> -->\n        tempElm.innerHTML = tabMatch[2].trim()\n          ? vm.compiler.compile(tabMatch[2]).replace(/<\\/?p>/g, '')\n          : `Tab ${tabIndex}`;\n\n        const tabTitle = tempElm.innerHTML;\n        const tabContent = (tabMatch[3] || '').trim();\n        const tabData = (\n          tempElm.textContent ||\n          tempElm.firstChild.getAttribute('alt') ||\n          tempElm.firstChild.getAttribute('src')\n        )\n          .trim()\n          .toLowerCase();\n\n        // Use replace function to avoid regex special replacement\n        // strings being processed ($$, $&, $`, $', $n)\n        tabBlockOut = tabBlockOut.replace(tabMatch[0], () =>\n          [\n            `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabData}\">${tabTitle}</button> -->`,\n            `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabData}\"> -->`,\n            `\\n\\n${tabBlockIndent}${tabContent}`,\n            `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`\n          ].join('')\n        );\n\n        tabIndex++;\n      }\n    }\n\n    tabBlockOut = tabBlockOut.replace(tabBlockStart, () => tabStartReplacement);\n    tabBlockOut = tabBlockOut.replace(tabBlockEnd, () => tabEndReplacement);\n    content = content.replace(tabBlockMatch[0], () => tabBlockOut);\n\n    tabBlockMatch = content.match(regex.tabBlockMarkup);\n  }\n\n  // Restore code blocks\n  codeBlockMarkers.forEach((item, i) => {\n    content = content.replace(item, () => codeBlockMatch[i]);\n  });\n\n  return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n  let tabReplaceMatch;\n\n  while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n    const tabComment = tabReplaceMatch[0];\n    const tabReplacement = tabReplaceMatch[1] || '';\n\n    html = html.replace(tabComment, () => tabReplacement);\n  }\n\n  return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: the tab containing the\n * matching element ID from the URL, the first tab in the group, or the last tab\n * clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n  const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n  const tabBlocks = tabsContainer\n    ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`))\n    : [];\n  const tabStoragePersist = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n  const tabStorageSync = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n  setActiveTabFromAnchor();\n\n  tabBlocks.forEach((tabBlock, index) => {\n    let activeButton = Array.apply(null, tabBlock.children).filter(elm =>\n      matchSelector(elm, `.${classNames.tabButtonActive}`)\n    )[0];\n\n    if (!activeButton) {\n      if (settings.sync && tabStorageSync.length) {\n        activeButton = tabStorageSync\n          .map(\n            label =>\n              Array.apply(null, tabBlock.children).filter(elm =>\n                matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${label}\"]`)\n              )[0]\n          )\n          .filter(elm => elm)[0];\n      }\n\n      if (!activeButton && settings.persist) {\n        activeButton = Array.apply(null, tabBlock.children).filter(elm =>\n          matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${tabStoragePersist[index]}\"]`)\n        )[0];\n      }\n\n      activeButton = activeButton || tabBlock.querySelector(`.${classNames.tabButton}`);\n      activeButton && activeButton.classList.add(classNames.tabButtonActive);\n    }\n  });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm Tab toggle element to mark as active\n */\nfunction setActiveTab(elm, _isMatchingTabSync = false) {\n  const activeButton = getClosest(elm, `.${classNames.tabButton}`);\n\n  if (activeButton) {\n    const activeButtonLabel = activeButton.getAttribute('data-tab');\n    const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlock = activeButton.parentNode;\n    const tabButtons = Array.apply(null, tabBlock.children).filter(elm =>\n      matchSelector(elm, 'button')\n    );\n    const tabBlockOffset = tabBlock.offsetTop;\n\n    tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n    activeButton.classList.add(classNames.tabButtonActive);\n\n    if (!_isMatchingTabSync) {\n      if (settings.persist) {\n        const tabBlocks = tabsContainer\n          ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`))\n          : [];\n        const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n        const tabStorage = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n\n        tabStorage[tabBlockIndex] = activeButtonLabel;\n        sessionStorage.setItem(storageKeys.persist, JSON.stringify(tabStorage));\n      }\n\n      if (settings.sync) {\n        const tabButtonMatches = tabsContainer\n          ? Array.apply(\n              null,\n              tabsContainer.querySelectorAll(\n                `.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`\n              )\n            )\n          : [];\n        const tabStorage = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n        tabButtonMatches.forEach(tabButtonMatch => {\n          setActiveTab(tabButtonMatch, true);\n        });\n\n        // Maintain position in viewport when tab group's offset changes\n        window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n\n        // Remove existing label if not first in array\n        if (tabStorage.indexOf(activeButtonLabel) > 0) {\n          tabStorage.splice(tabStorage.indexOf(activeButtonLabel), 1);\n        }\n\n        // Add label if not already in first position\n        if (tabStorage.indexOf(activeButtonLabel) !== 0) {\n          tabStorage.unshift(activeButtonLabel);\n          sessionStorage.setItem(storageKeys.sync, JSON.stringify(tabStorage));\n        }\n      }\n    }\n  }\n}\n\n/**\n * Sets the active tab based on the anchor ID in the URL\n */\nfunction setActiveTabFromAnchor() {\n  const uriComponent = window.location.hash || window.location.search;\n  const anchorID = decodeURIComponent((uriComponent.match(/(?:id=)([^&]+)/) || [])[1]);\n  const anchorSelector = anchorID && `.${classNames.tabBlock} #${anchorID}`;\n  const isAnchorElmInTabBlock = anchorID && document.querySelector(anchorSelector);\n\n  if (isAnchorElmInTabBlock) {\n    const anchorElm = document.querySelector(`#${anchorID}`);\n\n    let tabContent;\n\n    if (anchorElm.closest) {\n      tabContent = anchorElm.closest(`.${classNames.tabContent}`);\n    } else {\n      tabContent = anchorElm.parentNode;\n\n      while (\n        tabContent !== document.body &&\n        !tabContent.classList.contains(`${classNames.tabContent}`)\n      ) {\n        tabContent = tabContent.parentNode;\n      }\n    }\n\n    setActiveTab(tabContent.previousElementSibling);\n  }\n}\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n  let hasTabs = false;\n\n  hook.beforeEach(function (content) {\n    hasTabs = regex.tabBlockMarkup.test(content);\n\n    if (hasTabs) {\n      content = renderTabsStage1(content, vm);\n    }\n\n    return content;\n  });\n\n  hook.afterEach(function (html, next) {\n    if (hasTabs) {\n      html = renderTabsStage2(html);\n    }\n\n    next(html);\n  });\n\n  hook.doneEach(function () {\n    if (hasTabs) {\n      setDefaultTabs();\n    }\n  });\n\n  hook.mounted(function () {\n    const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n    tabsContainer &&\n      tabsContainer.addEventListener('click', function handleTabClick(evt) {\n        setActiveTab(evt.target);\n      });\n  });\n}\n\nif (window) {\n  window.$docsify = window.$docsify || {};\n\n  // Add config object\n  window.$docsify.tabs = window.$docsify.tabs || {};\n\n  // Update settings based on $docsify config\n  Object.keys(window.$docsify.tabs).forEach(key => {\n    if (Object.prototype.hasOwnProperty.call(settings, key)) {\n      settings[key] = window.$docsify.tabs[key];\n    }\n  });\n\n  // Add plugin data\n  window.$docsify.tabs.version = pkgVersion;\n\n  // Init plugin\n  if (settings.tabComments || settings.tabHeadings) {\n    window.$docsify.plugins = [].concat(window.$docsify.plugins || [], docsifyTabs);\n  }\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","concat","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","storageKeys","window","location","pathname","getClosest","elm","closestSelectorString","Element","prototype","closest","isMatch","matchSelector","parentNode","selectorString","matches","msMatchesSelector","webkitMatchesSelector","call","renderTabsStage1","content","vm","codeBlockMatch","match","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","tempElm","tabBlockMatch","tabIndex","_loop","tabBlockOut","tabBlockIndent","tabBlockStart","tabBlockEnd","hasTabComments","test","hasTabHeadings","tabMatch","tabStartReplacement","tabEndReplacement","join","_loop2","innerHTML","trim","compiler","compile","tabTitle","tabData","textContent","getAttribute","toLowerCase","exec","forEach","renderTabsStage2","html","tabReplaceMatch","_loop3","tabComment","tabReplacement","setDefaultTabs","querySelector","tabBlocks","Array","apply","querySelectorAll","tabStoragePersist","JSON","parse","sessionStorage","getItem","tabStorageSync","setActiveTabFromAnchor","index","activeButton","children","filter","length","label","classList","add","setActiveTab","_isMatchingTabSync","arguments","undefined","activeButtonLabel","tabButtons","tabBlockOffset","offsetTop","buttonElm","remove","tabBlockIndex","indexOf","tabStorage","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","splice","unshift","uriComponent","hash","search","anchorID","decodeURIComponent","anchorSelector","isAnchorElmInTabBlock","anchorElm","body","contains","previousElementSibling","docsifyTabs","hook","hasTabs","beforeEach","afterEach","next","doneEach","mounted","addEventListener","handleTabClick","evt","target","$docsify","tabs","Object","keys","key","hasOwnProperty","version","pkgVersion","plugins"],"mappings":"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","x_google_ignoreList":[0]}