{"version":3,"file":"docsify-tabs.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n  tabsContainer: 'content',\n  tabBlock: 'docsify-tabs',\n  tabButton: 'docsify-tabs__tab',\n  tabButtonActive: 'docsify-tabs__tab--active',\n  tabContent: 'docsify-tabs__content'\n};\nconst regex = {\n  // Matches markdown code blocks (inline and multi-line)\n  // Example: ```text```\n  codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n  // Matches tab replacement comment\n  // 0: Match\n  // 1: Replacement HTML\n  commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*?) -->`),\n\n  // Matches inner-most tab set by start/end comment\n  // Ex: <!-- tabs:start --> (<!-- tabs:start --><!-- tabs:end -->) <!-- tabs:end -->\n  // 0: Match\n  // 1: Indent\n  // 2: Start comment: <!-- tabs:start -->\n  // 3: undefined\n  // 4: End comment: <!-- tabs:end -->\n  tabBlockMarkup:\n    /( *)(<!-+\\s+tabs:\\s*?start\\s+-+>)(?:(?!(<!-+\\s+tabs:\\s*?(?:start|end)\\s+-+>))[\\s\\S])*(<!-+\\s+tabs:\\s*?end\\s+-+>)/,\n\n  // Matches tab label and content\n  // 0: Match\n  // 1: Label: <!-- tab:Label -->\n  // 2: Content\n  tabCommentMarkup:\n    /[\\r\\n]*(\\s*)<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]*\\s*(?=<!-+\\s+tabs?:(?!replace))/m,\n\n  // Matches tab label and content\n  // 0: Match\n  // 1: Label: #### **Label** OR #### __Label__\n  // 2: Content\n  tabHeadingMarkup:\n    /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n  persist: true,\n  sync: true,\n  theme: 'classic',\n  tabComments: true,\n  tabHeadings: true\n};\n\nconst storageKeys = {\n  get persist() {\n    return `docsify-tabs.persist.${window.location.pathname}`;\n  },\n  sync: 'docsify-tabs.sync'\n};\n\n// Functions\n// =============================================================================\n/**\n * Traverses the element and its parents until it finds a node that matches the\n * provided selector string. Will return itself or the matching ancestor.\n *\n * @param {object} elm\n * @param {string} closestSelectorString\n * @return {(object|null)}\n */\nfunction getClosest(elm, closestSelectorString) {\n  if (Element.prototype.closest) {\n    return elm.closest(closestSelectorString);\n  }\n\n  while (elm) {\n    const isMatch = matchSelector(elm, closestSelectorString);\n\n    if (isMatch) {\n      return elm;\n    }\n\n    elm = elm.parentNode || null;\n  }\n\n  return elm;\n}\n\n/**\n * Checks to see if the element would be selected by the provided selectorString\n *\n * @param {object} elm\n * @param {string} selectorString\n * @return {boolean}\n */\nfunction matchSelector(elm, selectorString) {\n  const matches =\n    Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\n  return matches.call(elm, selectorString);\n}\n\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content, vm) {\n  const codeBlockMatch = content.match(regex.codeMarkup) || [];\n  const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n    const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n    // Replace code block with marker to ensure tab markup within code\n    // blocks is not processed. These markers are replaced with their\n    // associated code blocs after tabs have been processed.\n    content = content.replace(item, () => codeMarker);\n\n    return codeMarker;\n  });\n  const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n  const tempElm = document.createElement('div');\n\n  let tabBlockMatch = content.match(regex.tabBlockMarkup);\n  let tabIndex = 1;\n\n  // Process each tab set\n  while (tabBlockMatch) {\n    let tabBlockOut = tabBlockMatch[0];\n\n    const tabBlockIndent = tabBlockMatch[1];\n    const tabBlockStart = tabBlockMatch[2];\n    const tabBlockEnd = tabBlockMatch[4];\n    const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlockOut);\n    const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlockOut);\n\n    let tabMatch;\n    let tabStartReplacement = '';\n    let tabEndReplacement = '';\n\n    if (hasTabComments || hasTabHeadings) {\n      tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n      tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n      // Process each tab panel\n      while (\n        (tabMatch =\n          (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlockOut) : null) ||\n          (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlockOut) : null)) !== null\n      ) {\n        // Process tab title as markdown\n        // Ex: <!-- tab:**Bold** and <span style=\"color: red;\">red</span> -->\n        tempElm.innerHTML = tabMatch[2].trim()\n          ? vm.compiler.compile(tabMatch[2]).replace(/<\\/?p>/g, '')\n          : `Tab ${tabIndex}`;\n\n        const tabTitle = tempElm.innerHTML;\n        const tabContent = (tabMatch[3] || '').trim();\n        const tabData = (\n          tempElm.textContent ||\n          tempElm.firstChild.getAttribute('alt') ||\n          tempElm.firstChild.getAttribute('src')\n        )\n          .trim()\n          .toLowerCase();\n\n        // Use replace function to avoid regex special replacement\n        // strings being processed ($$, $&, $`, $', $n)\n        tabBlockOut = tabBlockOut.replace(tabMatch[0], () =>\n          [\n            `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabData}\">${tabTitle}</button> -->`,\n            `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabData}\"> -->`,\n            `\\n\\n${tabBlockIndent}${tabContent}`,\n            `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`\n          ].join('')\n        );\n\n        tabIndex++;\n      }\n    }\n\n    tabBlockOut = tabBlockOut.replace(tabBlockStart, () => tabStartReplacement);\n    tabBlockOut = tabBlockOut.replace(tabBlockEnd, () => tabEndReplacement);\n    content = content.replace(tabBlockMatch[0], () => tabBlockOut);\n\n    tabBlockMatch = content.match(regex.tabBlockMarkup);\n  }\n\n  // Restore code blocks\n  codeBlockMarkers.forEach((item, i) => {\n    content = content.replace(item, () => codeBlockMatch[i]);\n  });\n\n  return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n  let tabReplaceMatch;\n\n  while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n    const tabComment = tabReplaceMatch[0];\n    const tabReplacement = tabReplaceMatch[1] || '';\n\n    html = html.replace(tabComment, () => tabReplacement);\n  }\n\n  return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: the tab containing the\n * matching element ID from the URL, the first tab in the group, or the last tab\n * clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n  const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n  const tabBlocks = tabsContainer\n    ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`))\n    : [];\n  const tabStoragePersist = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n  const tabStorageSync = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n  setActiveTabFromAnchor();\n\n  tabBlocks.forEach((tabBlock, index) => {\n    let activeButton = Array.apply(null, tabBlock.children).filter(elm =>\n      matchSelector(elm, `.${classNames.tabButtonActive}`)\n    )[0];\n\n    if (!activeButton) {\n      if (settings.sync && tabStorageSync.length) {\n        activeButton = tabStorageSync\n          .map(\n            label =>\n              Array.apply(null, tabBlock.children).filter(elm =>\n                matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${label}\"]`)\n              )[0]\n          )\n          .filter(elm => elm)[0];\n      }\n\n      if (!activeButton && settings.persist) {\n        activeButton = Array.apply(null, tabBlock.children).filter(elm =>\n          matchSelector(elm, `.${classNames.tabButton}[data-tab=\"${tabStoragePersist[index]}\"]`)\n        )[0];\n      }\n\n      activeButton = activeButton || tabBlock.querySelector(`.${classNames.tabButton}`);\n      activeButton && activeButton.classList.add(classNames.tabButtonActive);\n    }\n  });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm Tab toggle element to mark as active\n */\nfunction setActiveTab(elm, _isMatchingTabSync = false) {\n  const activeButton = getClosest(elm, `.${classNames.tabButton}`);\n\n  if (activeButton) {\n    const activeButtonLabel = activeButton.getAttribute('data-tab');\n    const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlock = activeButton.parentNode;\n    const tabButtons = Array.apply(null, tabBlock.children).filter(elm =>\n      matchSelector(elm, 'button')\n    );\n    const tabBlockOffset = tabBlock.offsetTop;\n\n    tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n    activeButton.classList.add(classNames.tabButtonActive);\n\n    if (!_isMatchingTabSync) {\n      if (settings.persist) {\n        const tabBlocks = tabsContainer\n          ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`))\n          : [];\n        const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n        const tabStorage = JSON.parse(sessionStorage.getItem(storageKeys.persist)) || {};\n\n        tabStorage[tabBlockIndex] = activeButtonLabel;\n        sessionStorage.setItem(storageKeys.persist, JSON.stringify(tabStorage));\n      }\n\n      if (settings.sync) {\n        const tabButtonMatches = tabsContainer\n          ? Array.apply(\n              null,\n              tabsContainer.querySelectorAll(\n                `.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`\n              )\n            )\n          : [];\n        const tabStorage = JSON.parse(sessionStorage.getItem(storageKeys.sync)) || [];\n\n        tabButtonMatches.forEach(tabButtonMatch => {\n          setActiveTab(tabButtonMatch, true);\n        });\n\n        // Maintain position in viewport when tab group's offset changes\n        window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n\n        // Remove existing label if not first in array\n        if (tabStorage.indexOf(activeButtonLabel) > 0) {\n          tabStorage.splice(tabStorage.indexOf(activeButtonLabel), 1);\n        }\n\n        // Add label if not already in first position\n        if (tabStorage.indexOf(activeButtonLabel) !== 0) {\n          tabStorage.unshift(activeButtonLabel);\n          sessionStorage.setItem(storageKeys.sync, JSON.stringify(tabStorage));\n        }\n      }\n    }\n  }\n}\n\n/**\n * Sets the active tab based on the anchor ID in the URL\n */\nfunction setActiveTabFromAnchor() {\n  const uriComponent = window.location.hash || window.location.search;\n  const anchorID = decodeURIComponent((uriComponent.match(/(?:id=)([^&]+)/) || [])[1]);\n  const anchorSelector = anchorID && `.${classNames.tabBlock} #${anchorID}`;\n  const isAnchorElmInTabBlock = anchorID && document.querySelector(anchorSelector);\n\n  if (isAnchorElmInTabBlock) {\n    const anchorElm = document.querySelector(`#${anchorID}`);\n\n    let tabContent;\n\n    if (anchorElm.closest) {\n      tabContent = anchorElm.closest(`.${classNames.tabContent}`);\n    } else {\n      tabContent = anchorElm.parentNode;\n\n      while (\n        tabContent !== document.body &&\n        !tabContent.classList.contains(`${classNames.tabContent}`)\n      ) {\n        tabContent = tabContent.parentNode;\n      }\n    }\n\n    setActiveTab(tabContent.previousElementSibling);\n  }\n}\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n  let hasTabs = false;\n\n  hook.beforeEach(function (content) {\n    hasTabs = regex.tabBlockMarkup.test(content);\n\n    if (hasTabs) {\n      content = renderTabsStage1(content, vm);\n    }\n\n    return content;\n  });\n\n  hook.afterEach(function (html, next) {\n    if (hasTabs) {\n      html = renderTabsStage2(html);\n    }\n\n    next(html);\n  });\n\n  hook.doneEach(function () {\n    if (hasTabs) {\n      setDefaultTabs();\n    }\n  });\n\n  hook.mounted(function () {\n    const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n    tabsContainer &&\n      tabsContainer.addEventListener('click', function handleTabClick(evt) {\n        setActiveTab(evt.target);\n      });\n  });\n}\n\nif (window) {\n  window.$docsify = window.$docsify || {};\n\n  // Add config object\n  window.$docsify.tabs = window.$docsify.tabs || {};\n\n  // Update settings based on $docsify config\n  Object.keys(window.$docsify.tabs).forEach(key => {\n    if (Object.prototype.hasOwnProperty.call(settings, key)) {\n      settings[key] = window.$docsify.tabs[key];\n    }\n  });\n\n  // Add plugin data\n  window.$docsify.tabs.version = pkgVersion;\n\n  // Init plugin\n  if (settings.tabComments || settings.tabHeadings) {\n    window.$docsify.plugins = [].concat(window.$docsify.plugins || [], docsifyTabs);\n  }\n}\n"],"names":["css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","concat","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","storageKeys","window","location","pathname","matchSelector","elm","selectorString","Element","prototype","matches","msMatchesSelector","webkitMatchesSelector","call","setDefaultTabs","querySelector","tabBlocks","Array","apply","querySelectorAll","tabStoragePersist","JSON","parse","sessionStorage","getItem","tabStorageSync","uriComponent","hash","search","anchorID","decodeURIComponent","match","anchorSelector","anchorElm","closest","parentNode","body","classList","contains","setActiveTab","previousElementSibling","setActiveTabFromAnchor","forEach","index","activeButton","children","filter","length","map","label","add","_isMatchingTabSync","arguments","undefined","closestSelectorString","getClosest","activeButtonLabel","getAttribute","tabButtons","tabBlockOffset","offsetTop","buttonElm","remove","tabBlockIndex","indexOf","tabStorage","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","splice","unshift","$docsify","tabs","Object","keys","key","hasOwnProperty","version","plugins","hook","vm","hasTabs","beforeEach","content","test","codeBlockMatch","codeBlockMarkers","item","i","codeMarker","replace","tabTheme","tempElm","tabBlockMatch","tabIndex","_loop","tabMatch","tabBlockOut","tabBlockIndent","tabBlockStart","tabBlockEnd","hasTabComments","hasTabHeadings","tabStartReplacement","tabEndReplacement","join","_loop2","innerHTML","trim","compiler","compile","tabTitle","tabData","textContent","toLowerCase","exec","renderTabsStage1","afterEach","html","next","tabReplaceMatch","_loop3","tabComment","tabReplacement","renderTabsStage2","doneEach","mounted","addEventListener","evt","target"],"mappings":"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","x_google_ignoreList":[0]}